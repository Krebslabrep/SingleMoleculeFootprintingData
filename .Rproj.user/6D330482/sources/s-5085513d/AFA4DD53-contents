#!/usr/bin/env nextflow

///////////////////////
// DEFINE PARAMETERS //
///////////////////////

// Paramters that affect steps executed when params.Aligned=false
params.NGS_dir="" // when params.Aligned == true, this serves as a suffix string for output files
params.InputPattern="*_{1,2}_sequence.txt.gz" // modify if smt more specific needed //this really only affect the definition of the Channel for the fastq files

params.Aligned=false
//params.paired="fr" // set to "no" for single-end libraries
params.SNPs=false
params.FootprintingQConly=false
params.Deduplicate=true

// Parameters for methylation calling
// params.ExperimentType="WT"

// General parameters
User="barzaghi"
UserEmail="guido.barzaghi@embl.de"
Slurm_reports_dir="/g/krebs/${User}/bash_scripts/slurm_err_out"
params.Publish_dir="/g/krebs/${User}/HTS/SMF/MM/${params.NGS_dir}"














///////////////////////////
// DEFINE INPUT CHANNELS //
///////////////////////////

// according to params.Aligned
	// if false, make channels canonically .fromFilePairs
	// if true, make mock channels: true input taken from "${params.Publish_dir}/aln"

if ( params.Aligned == false ){

	println "Proceeding in unaligned mode"

	Channel
 		//.fromFilePairs("/g/krebs/NGS_Data_Library/${params.NGS_dir}/lane1/*/fastq/${params.InputPattern}")
		.fromFilePairs("/g/krebs/NGS_Data_Library/${params.NGS_dir}/${params.InputPattern}")
		.dump(tag: 'files')
		.set { fastq_pairs }

  // NOTE: This is not ready... params.Deduplicate should be evaluated inside the process but it's not...I need to study what needs to be done here
	// if ( params.Deduplicate == true ){
	// 	bam_dedup = Channel.value("placeholder")
	// 	bai_dedup = Channel.value("placeholder")
	// } else {
	// 	bam_dedup = Channel.empty()
	// 	bai_dedup = Channel.empty()

	// 	bam_MethCall = Channel.value("placeholder")
	// 	bai_MethCall = Channel.value("placeholder")
	// }

} else {

	println "Proceeding in Aligned mode"

	bam_QC = Channel.value("placeholder")
	bai_QC = Channel.value("placeholder")

	bam_QC2 = Channel.value("placeholder")
	bai_QC2 = Channel.value("placeholder")

	if ( params.Deduplicate == true ){
		bam_dedup = Channel.value("placeholder")
		bai_dedup = Channel.value("placeholder")
	} else {
		bam_dedup = Channel.empty()
		bai_dedup = Channel.empty()

		bam_MethCall = Channel.value("placeholder")
		bai_MethCall = Channel.value("placeholder")
	}

	// not very elegant
	fastq_pairs = Channel.empty()
}













//////////////////////
// DEFINE PROCESSES //
//////////////////////

process Trim_adapters {

	//executor 'local'
	executor 'slurm'
	cpus 4
	time '12h'
	memory '1GB'
	clusterOptions "--qos=high -A Krebs -o ${Slurm_reports_dir}/slurm.%N.%j.out -e ${Slurm_reports_dir}/slurm.%N.%j.err"

	when:
	params.Aligned == false

	input:
	tuple val(pair_id), path(reads) from fastq_pairs

	output:
	set val(pair_id), path("${pair_id}_*_val_{1,2}.fq.gz") into trimmed_fastqs

	"""
	rename txt fq $reads
	zcat *1_sequence.fq.gz | gzip > "${pair_id}_1_sequence_1.fq.gz"
	zcat *2_sequence.fq.gz | gzip > "${pair_id}_2_sequence_2.fq.gz"

	trim_galore -j 4 --paired -a NAGATCGGAAGAG --stringency 2 "${pair_id}_1_sequence_1.fq.gz" "${pair_id}_2_sequence_2.fq.gz"
	"""

}

process Align_reads {

	executor 'slurm'
	cpus 1
	time '60h'
	memory '180GB'
	clusterOptions "--qos=high -A Krebs -o ${Slurm_reports_dir}/slurm.%N.%j.out -e ${Slurm_reports_dir}/slurm.%N.%j.err"

	tag "Performing QuasR alignment"

	when:
	params.Aligned == false

	input:
	tuple val(pair_id), path(reads) from trimmed_fastqs

	output:
	set val(pair_id), path("*bam") into bam
	set val(pair_id), path("*.bam.bai") into bai

	script:
	if (params.SNPs == true)
		"""
		echo "FileName1	FileName2	SampleName" > "QuasR_input_trimmed_${pair_id}.txt"
		echo "${pair_id}_1_sequence_1_val_1.fq.gz	${pair_id}_2_sequence_2_val_2.fq.gz	${pair_id}" >> "QuasR_input_trimmed_${pair_id}.txt"

		module load R-bundle-Bioconductor-GBCS/3.10-foss-2019b-R-3.6.2
		Rscript /g/krebs/barzaghi/Rscripts/QuasR_align.R "QuasR_input_trimmed_${pair_id}.txt" "true"
		"""
	else if (params.SNPs == false)
		"""
		echo "FileName1 FileName2   SampleName" > "QuasR_input_trimmed_${pair_id}.txt"
		echo "${pair_id}_1_sequence_1_val_1.fq.gz   ${pair_id}_2_sequence_2_val_2.fq.gz ${pair_id}" >> "QuasR_input_trimmed_${pair_id}.txt"

		module load R-bundle-Bioconductor-GBCS/3.10-foss-2019b-R-3.6.2
		Rscript /g/krebs/barzaghi/Rscripts/QuasR_align.R "QuasR_input_trimmed_${pair_id}.txt" "false"
		"""
}

process Split_alleles {

	executor 'slurm'
	cpus 4
	time '2h'
	memory '1GB'
	clusterOptions "--qos=high -A Krebs -o ${Slurm_reports_dir}/slurm.%N.%j.out -e ${Slurm_reports_dir}/slurm.%N.%j.err"

	tag 'Split bam file according to allele and index them if SNPs != "". Just rename and publish otherwise.'
	publishDir "${params.Publish_dir}/aln", mode: 'copy', pattern: "*.bam"
	publishDir "${params.Publish_dir}/aln", mode: 'copy', pattern: "*.bai"

	when:
	params.Aligned == false

	input:
	tuple val(id), path(bam_tmp) from bam
	tuple val(id), path(bai_tmp) from bai

	output:
	path("*.bam") into (bam_QC, bam_QC2, bam_dedup)
	path("*.bai") into (bai_QC, bai_QC2, bai_dedup)

	script:
	if (params.SNPs == true)
		"""
		(samtools view -H $bam_tmp; samtools view $bam_tmp | awk '{if (\$17 == "XV:A:R") print \$0}') | samtools view -b -o "R_${id}.bam"
		(samtools view -H $bam_tmp; samtools view $bam_tmp | awk '{if (\$17 == "XV:A:A") print \$0}') | samtools view -b -o "A_${id}.bam"

		samtools index -@4 "R_${id}.bam"
		samtools index -@4 "A_${id}.bam"

		mkdir -p "${params.Publish_dir}/aln"

		ls ./ | grep -v "^[R,A]" | xargs -r rm --
		"""
	else if (params.SNPs == false)
		"""
		mkdir -p "${params.Publish_dir}/aln"

		mv "${bam_tmp}" "${id}.bam"
		mv "${bai_tmp}" "${id}.bai"
		"""

}

process QuasR_report {

	executor 'slurm'
	cpus 1
	time '13h'
	memory '160GB'
	clusterOptions "--qos=high -A Krebs -o ${Slurm_reports_dir}/slurm.%N.%j.out -e ${Slurm_reports_dir}/slurm.%N.%j.err"

	tag "Gather all aligned files and produce QuasR report"
	publishDir "${params.Publish_dir}/aln_reports", mode: 'copy', pattern: "QuasR_input_aln_${params.NGS_dir}.pdf"

	// input is just mock to wait for collection, truly using input from publishDir
	input:
	val(bam) from bam_QC.collect()
	val(bai) from bai_QC.collect()

	output:
	path("QuasR_input_aln_${params.NGS_dir}.pdf")

	"""
	echo "FileName	SampleName" > QuasR_input_aln_"${params.NGS_dir}".txt
	bash /g/krebs/barzaghi/bash_scripts/MakeQuasRInput.sh "${params.Publish_dir}/aln" >> QuasR_input_aln_"${params.NGS_dir}".txt

	mkdir -p "${params.Publish_dir}/aln_reports"
	module load R-bundle-Bioconductor-GBCS/3.10-foss-2019b-R-3.6.2
	Rscript /g/krebs/barzaghi/Rscripts/QuasR_QC_report.R "QuasR_input_aln_${params.NGS_dir}.txt"
	"""

}

process Footprinting_QC {

	executor 'slurm'
	cpus 1
	time '15h'
	memory '185GB'
	clusterOptions "--qos=high -A Krebs -o ${Slurm_reports_dir}/slurm.%N.%j.out -e ${Slurm_reports_dir}/slurm.%N.%j.err"

	tag 'Check bait capture efficiency and conversion rate'
	publishDir "${params.Publish_dir}/aln_reports", mode: 'copy', pattern: "sequencing_quality_metrics.csv"

	// input is just mock to wait for collection, truly using input from publishDir
	input:
	val(bam) from bam_QC2.collect()
	val(bai) from bai_QC2.collect()

	output:
	path('sequencing_quality_metrics.csv')

	"""
	echo "FileName	SampleName" > QuasR_input_aln_"${params.NGS_dir}".txt
	bash /g/krebs/barzaghi/bash_scripts/MakeQuasRInput.sh "${params.Publish_dir}/aln" >> QuasR_input_aln_"${params.NGS_dir}".txt

	mkdir -p "${params.Publish_dir}/aln_reports"
	module load R-bundle-Bioconductor-GBCS/3.10-foss-2019b-R-3.6.2
	Rscript /g/krebs/barzaghi/Rscripts/sequencing_quality_metrics.R "QuasR_input_aln_${params.NGS_dir}.txt"
	"""

}

process deduplicate {

	executor 'slurm'
	cpus 1
	time '20h'
	memory '200GB'
	clusterOptions "--qos=high -A Krebs -o ${Slurm_reports_dir}/slurm.%N.%j.out -e ${Slurm_reports_dir}/slurm.%N.%j.err"

	tag "Deduplicate all bamfiles at the same time. If sample names match the bam files will be merged"
	publishDir "${params.Publish_dir}/aln_mrg_ddup", mode: 'copy', pattern: "*dp_rm.bam*"
	publishDir "${params.Publish_dir}/aln_mrg_ddup", mode: 'copy', pattern: "*_stats.txt"

	when:
	params.FootprintingQConly == false

	// input is just mock to wait for collection, truly using input from publishDir
	input:
	val(bam) from bam_dedup.collect()
	val(bai) from bai_dedup.collect()

	output:
	path("*dp_rm.bam*")
	val("placeholder") into (bam_MethCall)                                                                                                       // , bam_Sorting
	val("placeholder") into (bai_MethCall)                                                                                                       // , bai_Sorting

	script:
	if (params.Deduplicate == true)
	"""
	echo "FileName	SampleName" > QuasR_input_aln_"${params.NGS_dir}".txt
	bash /g/krebs/barzaghi/bash_scripts/MakeQuasRInput.sh "${params.Publish_dir}/aln" >> QuasR_input_aln_"${params.NGS_dir}".txt

	mkdir -p "${params.Publish_dir}/aln_mrg_ddup"
	module load R-bundle-Bioconductor-GBCS/3.10-foss-2019b-R-3.6.2
	Rscript /g/krebs/barzaghi/Rscripts/WG_MM_remove-duplicate_v2.r "QuasR_input_aln_${params.NGS_dir}.txt"
	"""
	else if (params.Deduplicate == false)
	"""
	echo "Skipping deduplication"
	"""
}

process CallMethylation {

	executor 'slurm'
	cpus 1
	time '19h'
	memory '200GB'
	clusterOptions "--qos=high -A Krebs -o ${Slurm_reports_dir}/slurm.%N.%j.out -e ${Slurm_reports_dir}/slurm.%N.%j.err"

	tag "Call context methylation"
	publishDir "${params.Publish_dir}/ContextMethCall", mode: 'copy', pattern: "*.rds"

	when:
	params.FootprintingQConly == false

	// input is just mock to wait for collection, truly using input from publishDir
	input:
	val(bam) from bam_MethCall.collect()
	val(bai) from bai_MethCall.collect()

	output:
	path("*.rds") into CallMethQC

	"""
	echo "FileName	SampleName" > QuasR_input_aln_"${params.NGS_dir}".txt
	if [[ "${params.Deduplicate}" == true ]]; then
		bash /g/krebs/barzaghi/bash_scripts/MakeQuasRInput.sh "${params.Publish_dir}/aln_mrg_ddup" >> QuasR_input_aln_"${params.NGS_dir}".txt
	else
		bash /g/krebs/barzaghi/bash_scripts/MakeQuasRInput.sh "${params.Publish_dir}/aln" >> QuasR_input_aln_"${params.NGS_dir}".txt
	fi

	mkdir -p "${params.Publish_dir}/ContextMethCall"
	module load R-bundle-Bioconductor-GBCS/3.10-foss-2019b-R-3.6.2
	Rscript /g/krebs/barzaghi/bash_scripts/KrebsLabRepo/Soenmezer_2020_SMF/single_molecule_TF_call/context_methylation_call.r "QuasR_input_aln_${params.NGS_dir}.txt" "./"
	"""

}











